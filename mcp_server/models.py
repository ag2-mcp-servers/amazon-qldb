# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T13:04:45+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, ConfigDict, Field, RootModel, SecretStr, conint, constr


class Arn(RootModel[constr(min_length=20, max_length=1600)]):
    root: constr(min_length=20, max_length=1600)


class Boolean(RootModel[bool]):
    root: bool


class CancelJournalKinesisStreamRequest(BaseModel):
    pass


class DeleteLedgerRequest(BaseModel):
    pass


class DeletionProtection(RootModel[bool]):
    root: bool


class DescribeJournalKinesisStreamRequest(BaseModel):
    pass


class DescribeJournalS3ExportRequest(BaseModel):
    pass


class DescribeLedgerRequest(BaseModel):
    pass


class Digest(RootModel[constr(min_length=32, max_length=32)]):
    root: constr(min_length=32, max_length=32)


class EncryptionStatus(Enum):
    ENABLED = 'ENABLED'
    UPDATING = 'UPDATING'
    KMS_KEY_INACCESSIBLE = 'KMS_KEY_INACCESSIBLE'


class ErrorCause(Enum):
    KINESIS_STREAM_NOT_FOUND = 'KINESIS_STREAM_NOT_FOUND'
    IAM_PERMISSION_REVOKED = 'IAM_PERMISSION_REVOKED'


class ExportStatus(Enum):
    IN_PROGRESS = 'IN_PROGRESS'
    COMPLETED = 'COMPLETED'
    CANCELLED = 'CANCELLED'


class GetDigestRequest(BaseModel):
    pass


class InvalidParameterException(RootModel[Any]):
    root: Any


class IonText(RootModel[SecretStr]):
    root: SecretStr


class KinesisConfiguration(BaseModel):
    AggregationEnabled: Optional[Boolean] = None
    StreamArn: Arn


class KmsKey(RootModel[constr(max_length=1600)]):
    root: constr(max_length=1600)


class LedgerName(
    RootModel[
        constr(
            pattern=r'(?!^.*--)(?!^[0-9]+$)(?!^-)(?!.*-$)^[A-Za-z0-9-]+$',
            min_length=1,
            max_length=32,
        )
    ]
):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    root: constr(
        pattern=r'(?!^.*--)(?!^[0-9]+$)(?!^-)(?!.*-$)^[A-Za-z0-9-]+$',
        min_length=1,
        max_length=32,
    )


class LedgerState(Enum):
    CREATING = 'CREATING'
    ACTIVE = 'ACTIVE'
    DELETING = 'DELETING'
    DELETED = 'DELETED'


class LimitExceededException(RootModel[Any]):
    root: Any


class ListJournalKinesisStreamsForLedgerRequest(BaseModel):
    pass


class ListJournalS3ExportsForLedgerRequest(BaseModel):
    pass


class ListJournalS3ExportsRequest(BaseModel):
    pass


class ListLedgersRequest(BaseModel):
    pass


class ListTagsForResourceRequest(BaseModel):
    pass


class MaxResults(RootModel[conint(ge=1, le=100)]):
    root: conint(ge=1, le=100)


class NextToken(
    RootModel[constr(pattern=r'^[A-Za-z-0-9+/=]+$', min_length=4, max_length=1024)]
):
    root: constr(pattern=r'^[A-Za-z-0-9+/=]+$', min_length=4, max_length=1024)


class OutputFormat(Enum):
    ION_BINARY = 'ION_BINARY'
    ION_TEXT = 'ION_TEXT'
    JSON = 'JSON'


class PermissionsMode(Enum):
    ALLOW_ALL = 'ALLOW_ALL'
    STANDARD = 'STANDARD'


class ResourceAlreadyExistsException(RootModel[Any]):
    root: Any


class ResourceInUseException(RootModel[Any]):
    root: Any


class ResourceNotFoundException(RootModel[Any]):
    root: Any


class ResourcePreconditionNotMetException(RootModel[Any]):
    root: Any


class S3Bucket(
    RootModel[constr(pattern=r'^[A-Za-z-0-9-_.]+$', min_length=3, max_length=255)]
):
    root: constr(pattern=r'^[A-Za-z-0-9-_.]+$', min_length=3, max_length=255)


class S3ObjectEncryptionType(Enum):
    SSE_KMS = 'SSE_KMS'
    SSE_S3 = 'SSE_S3'
    NO_ENCRYPTION = 'NO_ENCRYPTION'


class S3Prefix(RootModel[constr(min_length=0, max_length=128)]):
    root: constr(min_length=0, max_length=128)


class StreamName(
    RootModel[
        constr(
            pattern=r'(?!^.*--)(?!^[0-9]+$)(?!^-)(?!.*-$)^[A-Za-z0-9-]+$',
            min_length=1,
            max_length=32,
        )
    ]
):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    root: constr(
        pattern=r'(?!^.*--)(?!^[0-9]+$)(?!^-)(?!.*-$)^[A-Za-z0-9-]+$',
        min_length=1,
        max_length=32,
    )


class StreamStatus(Enum):
    ACTIVE = 'ACTIVE'
    COMPLETED = 'COMPLETED'
    CANCELED = 'CANCELED'
    FAILED = 'FAILED'
    IMPAIRED = 'IMPAIRED'


class TagKey(RootModel[constr(min_length=1, max_length=128)]):
    root: constr(min_length=1, max_length=128)


class TagKeyList(RootModel[List[TagKey]]):
    root: List[TagKey] = Field(..., max_length=200, min_length=0)


class TagResourceResponse(BaseModel):
    pass


class TagValue(RootModel[constr(min_length=0, max_length=256)]):
    root: constr(min_length=0, max_length=256)


class Tags(RootModel[Optional[Dict[str, TagValue]]]):
    root: Optional[Dict[str, TagValue]] = None


class Timestamp(RootModel[datetime]):
    root: datetime


class UniqueId(
    RootModel[constr(pattern=r'^[A-Za-z-0-9]+$', min_length=22, max_length=22)]
):
    root: constr(pattern=r'^[A-Za-z-0-9]+$', min_length=22, max_length=22)


class UntagResourceRequest(BaseModel):
    pass


class UntagResourceResponse(BaseModel):
    pass


class UpdateLedgerPermissionsModeRequest(BaseModel):
    PermissionsMode_1: PermissionsMode = Field(..., alias='PermissionsMode')


class UpdateLedgerPermissionsModeResponse(BaseModel):
    Arn_1: Optional[Arn] = Field(None, alias='Arn')
    Name: Optional[LedgerName] = None
    PermissionsMode_1: Optional[PermissionsMode] = Field(None, alias='PermissionsMode')


class UpdateLedgerRequest(BaseModel):
    DeletionProtection_1: Optional[DeletionProtection] = Field(
        None, alias='DeletionProtection'
    )
    KmsKey_1: Optional[KmsKey] = Field(None, alias='KmsKey')


class ValueHolder(BaseModel):
    IonText_1: Optional[IonText] = Field(None, alias='IonText')


class LedgersPostRequest(BaseModel):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    DeletionProtection: Optional[bool] = Field(
        None,
        description='<p>The flag that prevents a ledger from being deleted by any user. If not provided on ledger creation, this feature is enabled (<code>true</code>) by default.</p> <p>If deletion protection is enabled, you must first disable it before you can delete the ledger. You can disable it by calling the <code>UpdateLedger</code> operation to set the flag to <code>false</code>.</p>',
    )
    KmsKey: Optional[constr(max_length=1600)] = Field(
        None,
        description='<p>The key in Key Management Service (KMS) to use for encryption of data at rest in the ledger. For more information, see <a href="https://docs.aws.amazon.com/qldb/latest/developerguide/encryption-at-rest.html">Encryption at rest</a> in the <i>Amazon QLDB Developer Guide</i>.</p> <p>Use one of the following options to specify this parameter:</p> <ul> <li> <p> <code>AWS_OWNED_KMS_KEY</code>: Use an KMS key that is owned and managed by Amazon Web Services on your behalf.</p> </li> <li> <p> <b>Undefined</b>: By default, use an Amazon Web Services owned KMS key.</p> </li> <li> <p> <b>A valid symmetric customer managed KMS key</b>: Use the specified KMS key in your account that you create, own, and manage.</p> <p>Amazon QLDB does not support asymmetric keys. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html">Using symmetric and asymmetric keys</a> in the <i>Key Management Service Developer Guide</i>.</p> </li> </ul> <p>To specify a customer managed KMS key, you can use its key ID, Amazon Resource Name (ARN), alias name, or alias ARN. When using an alias name, prefix it with <code>"alias/"</code>. To specify a key in a different Amazon Web Services account, you must use the key ARN or alias ARN.</p> <p>For example:</p> <ul> <li> <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code> </p> </li> <li> <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code> </p> </li> <li> <p>Alias name: <code>alias/ExampleAlias</code> </p> </li> <li> <p>Alias ARN: <code>arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias</code> </p> </li> </ul> <p>For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id">Key identifiers (KeyId)</a> in the <i>Key Management Service Developer Guide</i>.</p>',
    )
    Name: constr(
        pattern=r'(?!^.*--)(?!^[0-9]+$)(?!^-)(?!.*-$)^[A-Za-z0-9-]+$',
        min_length=1,
        max_length=32,
    ) = Field(
        ...,
        description='<p>The name of the ledger that you want to create. The name must be unique among all of the ledgers in your Amazon Web Services account in the current Region.</p> <p>Naming constraints for ledger names are defined in <a href="https://docs.aws.amazon.com/qldb/latest/developerguide/limits.html#limits.naming">Quotas in Amazon QLDB</a> in the <i>Amazon QLDB Developer Guide</i>.</p>',
    )
    PermissionsMode_1: PermissionsMode = Field(
        ...,
        alias='PermissionsMode',
        description='<p>The permissions mode to assign to the ledger that you want to create. This parameter can have one of the following values:</p> <ul> <li> <p> <code>ALLOW_ALL</code>: A legacy permissions mode that enables access control with API-level granularity for ledgers.</p> <p>This mode allows users who have the <code>SendCommand</code> API permission for this ledger to run all PartiQL commands (hence, <code>ALLOW_ALL</code>) on any tables in the specified ledger. This mode disregards any table-level or command-level IAM permissions policies that you create for the ledger.</p> </li> <li> <p> <code>STANDARD</code>: (<i>Recommended</i>) A permissions mode that enables access control with finer granularity for ledgers, tables, and PartiQL commands.</p> <p>By default, this mode denies all user requests to run any PartiQL commands on any tables in this ledger. To allow PartiQL commands to run, you must create IAM permissions policies for specific table resources and PartiQL actions, in addition to the <code>SendCommand</code> API permission for the ledger. For information, see <a href="https://docs.aws.amazon.com/qldb/latest/developerguide/getting-started-standard-mode.html">Getting started with the standard permissions mode</a> in the <i>Amazon QLDB Developer Guide</i>.</p> </li> </ul> <note> <p>We strongly recommend using the <code>STANDARD</code> permissions mode to maximize the security of your ledger data.</p> </note>',
    )
    Tags: Optional[Dict[str, TagValue]] = Field(
        None,
        description='The key-value pairs to add as tags to the ledger that you want to create. Tag keys are case sensitive. Tag values are case sensitive and can be null.',
    )


class LedgersNamePatchRequest(BaseModel):
    DeletionProtection: Optional[bool] = Field(
        None,
        description='<p>The flag that prevents a ledger from being deleted by any user. If not provided on ledger creation, this feature is enabled (<code>true</code>) by default.</p> <p>If deletion protection is enabled, you must first disable it before you can delete the ledger. You can disable it by calling the <code>UpdateLedger</code> operation to set the flag to <code>false</code>.</p>',
    )
    KmsKey: Optional[constr(max_length=1600)] = Field(
        None,
        description='<p>The key in Key Management Service (KMS) to use for encryption of data at rest in the ledger. For more information, see <a href="https://docs.aws.amazon.com/qldb/latest/developerguide/encryption-at-rest.html">Encryption at rest</a> in the <i>Amazon QLDB Developer Guide</i>.</p> <p>Use one of the following options to specify this parameter:</p> <ul> <li> <p> <code>AWS_OWNED_KMS_KEY</code>: Use an KMS key that is owned and managed by Amazon Web Services on your behalf.</p> </li> <li> <p> <b>Undefined</b>: Make no changes to the KMS key of the ledger.</p> </li> <li> <p> <b>A valid symmetric customer managed KMS key</b>: Use the specified KMS key in your account that you create, own, and manage.</p> <p>Amazon QLDB does not support asymmetric keys. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html">Using symmetric and asymmetric keys</a> in the <i>Key Management Service Developer Guide</i>.</p> </li> </ul> <p>To specify a customer managed KMS key, you can use its key ID, Amazon Resource Name (ARN), alias name, or alias ARN. When using an alias name, prefix it with <code>"alias/"</code>. To specify a key in a different Amazon Web Services account, you must use the key ARN or alias ARN.</p> <p>For example:</p> <ul> <li> <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code> </p> </li> <li> <p>Key ARN: <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code> </p> </li> <li> <p>Alias name: <code>alias/ExampleAlias</code> </p> </li> <li> <p>Alias ARN: <code>arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias</code> </p> </li> </ul> <p>For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id">Key identifiers (KeyId)</a> in the <i>Key Management Service Developer Guide</i>.</p>',
    )


class BlockAddress(BaseModel):
    IonText_1: Optional[IonText] = Field(None, alias='IonText')


class DigestTipAddress(BaseModel):
    IonText_1: Optional[IonText] = Field(None, alias='IonText')


class LedgersNameBlockPostRequest(BaseModel):
    BlockAddress_1: BlockAddress = Field(
        ...,
        alias='BlockAddress',
        description='A structure that can contain a value in multiple encoding formats.',
    )
    DigestTipAddress_1: Optional[DigestTipAddress] = Field(
        None,
        alias='DigestTipAddress',
        description='A structure that can contain a value in multiple encoding formats.',
    )


class KinesisConfiguration1(BaseModel):
    AggregationEnabled: Optional[Boolean] = None
    StreamArn: Optional[Arn] = None


class LedgersNameJournalKinesisStreamsPostRequest(BaseModel):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    ExclusiveEndTime: Optional[datetime] = Field(
        None,
        description="<p>The exclusive date and time that specifies when the stream ends. If you don't define this parameter, the stream runs indefinitely until you cancel it.</p> <p>The <code>ExclusiveEndTime</code> must be in <code>ISO 8601</code> date and time format and in Universal Coordinated Time (UTC). For example: <code>2019-06-13T21:36:34Z</code>.</p>",
    )
    InclusiveStartTime: datetime = Field(
        ...,
        description="<p>The inclusive start date and time from which to start streaming journal data. This parameter must be in <code>ISO 8601</code> date and time format and in Universal Coordinated Time (UTC). For example: <code>2019-06-13T21:36:34Z</code>.</p> <p>The <code>InclusiveStartTime</code> cannot be in the future and must be before <code>ExclusiveEndTime</code>.</p> <p>If you provide an <code>InclusiveStartTime</code> that is before the ledger's <code>CreationDateTime</code>, QLDB effectively defaults it to the ledger's <code>CreationDateTime</code>.</p>",
    )
    KinesisConfiguration: KinesisConfiguration1 = Field(
        ...,
        description='The configuration settings of the Amazon Kinesis Data Streams destination for an Amazon QLDB journal stream.',
    )
    RoleArn: constr(min_length=20, max_length=1600) = Field(
        ...,
        description='<p>The Amazon Resource Name (ARN) of the IAM role that grants QLDB permissions for a journal stream to write data records to a Kinesis Data Streams resource.</p> <p>To pass a role to QLDB when requesting a journal stream, you must have permissions to perform the <code>iam:PassRole</code> action on the IAM role resource. This is required for all journal stream requests.</p>',
    )
    StreamName: constr(
        pattern=r'(?!^.*--)(?!^[0-9]+$)(?!^-)(?!.*-$)^[A-Za-z0-9-]+$',
        min_length=1,
        max_length=32,
    ) = Field(
        ...,
        description='<p>The name that you want to assign to the QLDB journal stream. User-defined names can help identify and indicate the purpose of a stream.</p> <p>Your stream name must be unique among other <i>active</i> streams for a given ledger. Stream names have the same naming constraints as ledger names, as defined in <a href="https://docs.aws.amazon.com/qldb/latest/developerguide/limits.html#limits.naming">Quotas in Amazon QLDB</a> in the <i>Amazon QLDB Developer Guide</i>.</p>',
    )
    Tags: Optional[Dict[str, TagValue]] = Field(
        None,
        description='The key-value pairs to add as tags to the stream that you want to create. Tag keys are case sensitive. Tag values are case sensitive and can be null.',
    )


class LedgersNamePermissionsModePatchRequest(BaseModel):
    PermissionsMode_1: PermissionsMode = Field(
        ...,
        alias='PermissionsMode',
        description='<p>The permissions mode to assign to the ledger. This parameter can have one of the following values:</p> <ul> <li> <p> <code>ALLOW_ALL</code>: A legacy permissions mode that enables access control with API-level granularity for ledgers.</p> <p>This mode allows users who have the <code>SendCommand</code> API permission for this ledger to run all PartiQL commands (hence, <code>ALLOW_ALL</code>) on any tables in the specified ledger. This mode disregards any table-level or command-level IAM permissions policies that you create for the ledger.</p> </li> <li> <p> <code>STANDARD</code>: (<i>Recommended</i>) A permissions mode that enables access control with finer granularity for ledgers, tables, and PartiQL commands.</p> <p>By default, this mode denies all user requests to run any PartiQL commands on any tables in this ledger. To allow PartiQL commands to run, you must create IAM permissions policies for specific table resources and PartiQL actions, in addition to the <code>SendCommand</code> API permission for the ledger. For information, see <a href="https://docs.aws.amazon.com/qldb/latest/developerguide/getting-started-standard-mode.html">Getting started with the standard permissions mode</a> in the <i>Amazon QLDB Developer Guide</i>.</p> </li> </ul> <note> <p>We strongly recommend using the <code>STANDARD</code> permissions mode to maximize the security of your ledger data.</p> </note>',
    )


class LedgersNameRevisionPostRequest(BaseModel):
    BlockAddress_1: BlockAddress = Field(
        ...,
        alias='BlockAddress',
        description='A structure that can contain a value in multiple encoding formats.',
    )
    DigestTipAddress_1: Optional[DigestTipAddress] = Field(
        None,
        alias='DigestTipAddress',
        description='A structure that can contain a value in multiple encoding formats.',
    )
    DocumentId: constr(pattern=r'^[A-Za-z-0-9]+$', min_length=22, max_length=22) = (
        Field(
            ...,
            description='The UUID (represented in Base62-encoded text) of the document to be verified.',
        )
    )


class TagsResourceArnPostRequest(BaseModel):
    Tags: Dict[str, TagValue] = Field(
        ...,
        description='The key-value pairs to add as tags to the specified QLDB resource. Tag keys are case sensitive. If you specify a key that already exists for the resource, your request fails and returns an error. Tag values are case sensitive and can be null.',
    )


class TagKeys(RootModel[List[TagKey]]):
    root: List[TagKey] = Field(..., max_length=200, min_length=0)


class CancelJournalKinesisStreamResponse(BaseModel):
    StreamId: Optional[UniqueId] = None


class CreateLedgerRequest(BaseModel):
    DeletionProtection_1: Optional[DeletionProtection] = Field(
        None, alias='DeletionProtection'
    )
    KmsKey_1: Optional[KmsKey] = Field(None, alias='KmsKey')
    Name: LedgerName
    PermissionsMode_1: PermissionsMode = Field(..., alias='PermissionsMode')
    Tags_1: Optional[Tags] = Field(None, alias='Tags')


class CreateLedgerResponse(BaseModel):
    Arn_1: Optional[Arn] = Field(None, alias='Arn')
    CreationDateTime: Optional[Timestamp] = None
    DeletionProtection_1: Optional[DeletionProtection] = Field(
        None, alias='DeletionProtection'
    )
    KmsKeyArn: Optional[Arn] = None
    Name: Optional[LedgerName] = None
    PermissionsMode_1: Optional[PermissionsMode] = Field(None, alias='PermissionsMode')
    State: Optional[LedgerState] = None


class ExportJournalToS3Response(BaseModel):
    ExportId: UniqueId


class GetBlockRequest(BaseModel):
    BlockAddress: ValueHolder
    DigestTipAddress: Optional[ValueHolder] = None


class GetBlockResponse(BaseModel):
    Block: ValueHolder
    Proof: Optional[ValueHolder] = None


class GetDigestResponse(BaseModel):
    Digest_1: Digest = Field(..., alias='Digest')
    DigestTipAddress: ValueHolder


class GetRevisionRequest(BaseModel):
    BlockAddress: ValueHolder
    DigestTipAddress: Optional[ValueHolder] = None
    DocumentId: UniqueId


class GetRevisionResponse(BaseModel):
    Proof: Optional[ValueHolder] = None
    Revision: ValueHolder


class JournalKinesisStreamDescription(BaseModel):
    Arn_1: Optional[Arn] = Field(None, alias='Arn')
    CreationTime: Optional[Timestamp] = None
    ErrorCause_1: Optional[ErrorCause] = Field(None, alias='ErrorCause')
    ExclusiveEndTime: Optional[Timestamp] = None
    InclusiveStartTime: Optional[Timestamp] = None
    KinesisConfiguration_1: KinesisConfiguration = Field(
        ..., alias='KinesisConfiguration'
    )
    LedgerName_1: LedgerName = Field(..., alias='LedgerName')
    RoleArn: Arn
    Status: StreamStatus
    StreamId: UniqueId
    StreamName_1: StreamName = Field(..., alias='StreamName')


class JournalKinesisStreamDescriptionList(
    RootModel[List[JournalKinesisStreamDescription]]
):
    root: List[JournalKinesisStreamDescription]


class LedgerEncryptionDescription(BaseModel):
    EncryptionStatus_1: EncryptionStatus = Field(..., alias='EncryptionStatus')
    InaccessibleKmsKeyDateTime: Optional[Timestamp] = None
    KmsKeyArn: Arn


class LedgerSummary(BaseModel):
    CreationDateTime: Optional[Timestamp] = None
    Name: Optional[LedgerName] = None
    State: Optional[LedgerState] = None


class ListJournalKinesisStreamsForLedgerResponse(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    Streams: Optional[JournalKinesisStreamDescriptionList] = None


class ListTagsForResourceResponse(BaseModel):
    Tags_1: Optional[Tags] = Field(None, alias='Tags')


class S3EncryptionConfiguration(BaseModel):
    KmsKeyArn: Optional[Arn] = None
    ObjectEncryptionType: S3ObjectEncryptionType


class S3ExportConfiguration(BaseModel):
    Bucket: S3Bucket
    EncryptionConfiguration: S3EncryptionConfiguration
    Prefix: S3Prefix


class StreamJournalToKinesisRequest(BaseModel):
    ExclusiveEndTime: Optional[Timestamp] = None
    InclusiveStartTime: Timestamp
    KinesisConfiguration_1: KinesisConfiguration = Field(
        ..., alias='KinesisConfiguration'
    )
    RoleArn: Arn
    StreamName_1: StreamName = Field(..., alias='StreamName')
    Tags_1: Optional[Tags] = Field(None, alias='Tags')


class StreamJournalToKinesisResponse(BaseModel):
    StreamId: Optional[UniqueId] = None


class TagResourceRequest(BaseModel):
    Tags_1: Tags = Field(..., alias='Tags')


class UpdateLedgerResponse(BaseModel):
    Arn_1: Optional[Arn] = Field(None, alias='Arn')
    CreationDateTime: Optional[Timestamp] = None
    DeletionProtection_1: Optional[DeletionProtection] = Field(
        None, alias='DeletionProtection'
    )
    EncryptionDescription: Optional[LedgerEncryptionDescription] = None
    Name: Optional[LedgerName] = None
    State: Optional[LedgerState] = None


class S3ExportConfiguration1(BaseModel):
    Bucket: Optional[S3Bucket] = None
    EncryptionConfiguration: Optional[S3EncryptionConfiguration] = None
    Prefix: Optional[S3Prefix] = None


class LedgersNameJournalS3ExportsPostRequest(BaseModel):
    ExclusiveEndTime: datetime = Field(
        ...,
        description='<p>The exclusive end date and time for the range of journal contents to export.</p> <p>The <code>ExclusiveEndTime</code> must be in <code>ISO 8601</code> date and time format and in Universal Coordinated Time (UTC). For example: <code>2019-06-13T21:36:34Z</code>.</p> <p>The <code>ExclusiveEndTime</code> must be less than or equal to the current UTC date and time.</p>',
    )
    InclusiveStartTime: datetime = Field(
        ...,
        description="<p>The inclusive start date and time for the range of journal contents to export.</p> <p>The <code>InclusiveStartTime</code> must be in <code>ISO 8601</code> date and time format and in Universal Coordinated Time (UTC). For example: <code>2019-06-13T21:36:34Z</code>.</p> <p>The <code>InclusiveStartTime</code> must be before <code>ExclusiveEndTime</code>.</p> <p>If you provide an <code>InclusiveStartTime</code> that is before the ledger's <code>CreationDateTime</code>, Amazon QLDB defaults it to the ledger's <code>CreationDateTime</code>.</p>",
    )
    OutputFormat_1: Optional[OutputFormat] = Field(
        None,
        alias='OutputFormat',
        description='The output format of your exported journal data. If this parameter is not specified, the exported data defaults to <code>ION_TEXT</code> format.',
    )
    RoleArn: constr(min_length=20, max_length=1600) = Field(
        ...,
        description='<p>The Amazon Resource Name (ARN) of the IAM role that grants QLDB permissions for a journal export job to do the following:</p> <ul> <li> <p>Write objects into your Amazon Simple Storage Service (Amazon S3) bucket.</p> </li> <li> <p>(Optional) Use your customer managed key in Key Management Service (KMS) for server-side encryption of your exported data.</p> </li> </ul> <p>To pass a role to QLDB when requesting a journal export, you must have permissions to perform the <code>iam:PassRole</code> action on the IAM role resource. This is required for all journal export requests.</p>',
    )
    S3ExportConfiguration: S3ExportConfiguration1 = Field(
        ...,
        description='The Amazon Simple Storage Service (Amazon S3) bucket location in which a journal export job writes the journal contents.',
    )


class DescribeJournalKinesisStreamResponse(BaseModel):
    Stream: Optional[JournalKinesisStreamDescription] = None


class DescribeLedgerResponse(BaseModel):
    Arn_1: Optional[Arn] = Field(None, alias='Arn')
    CreationDateTime: Optional[Timestamp] = None
    DeletionProtection_1: Optional[DeletionProtection] = Field(
        None, alias='DeletionProtection'
    )
    EncryptionDescription: Optional[LedgerEncryptionDescription] = None
    Name: Optional[LedgerName] = None
    PermissionsMode_1: Optional[PermissionsMode] = Field(None, alias='PermissionsMode')
    State: Optional[LedgerState] = None


class ExportJournalToS3Request(BaseModel):
    ExclusiveEndTime: Timestamp
    InclusiveStartTime: Timestamp
    OutputFormat_1: Optional[OutputFormat] = Field(None, alias='OutputFormat')
    RoleArn: Arn
    S3ExportConfiguration_1: S3ExportConfiguration = Field(
        ..., alias='S3ExportConfiguration'
    )


class JournalS3ExportDescription(BaseModel):
    ExclusiveEndTime: Timestamp
    ExportCreationTime: Timestamp
    ExportId: UniqueId
    InclusiveStartTime: Timestamp
    LedgerName_1: LedgerName = Field(..., alias='LedgerName')
    OutputFormat_1: Optional[OutputFormat] = Field(None, alias='OutputFormat')
    RoleArn: Arn
    S3ExportConfiguration_1: S3ExportConfiguration = Field(
        ..., alias='S3ExportConfiguration'
    )
    Status: ExportStatus


class JournalS3ExportList(RootModel[List[JournalS3ExportDescription]]):
    root: List[JournalS3ExportDescription]


class LedgerList(RootModel[List[LedgerSummary]]):
    root: List[LedgerSummary]


class ListJournalS3ExportsForLedgerResponse(BaseModel):
    JournalS3Exports: Optional[JournalS3ExportList] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class ListJournalS3ExportsResponse(BaseModel):
    JournalS3Exports: Optional[JournalS3ExportList] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class ListLedgersResponse(BaseModel):
    Ledgers: Optional[LedgerList] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class DescribeJournalS3ExportResponse(BaseModel):
    ExportDescription: JournalS3ExportDescription
